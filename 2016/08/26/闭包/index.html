<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Javascript闭包 | 金城的妖精见过米</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Javascript闭包</h1><a id="logo" href="/.">金城的妖精见过米</a><p class="description">生命若给我无数张面孔，我永远选择最疼痛的一张去触摸</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Javascript闭包</h1><div class="post-meta">Aug 26, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/08/26/闭包/" href="/2016/08/26/闭包/#comments" class="ds-thread-count"></a><div class="post-content"><h3 id="Javascript闭包"><a href="#Javascript闭包" class="headerlink" title="Javascript闭包"></a>Javascript闭包</h3><p>闭包是指能够访问自由变量的函数 (变量在本地使用，但在闭包中定义)。换句话说，定义在闭包中的函数可以“记忆”它被创建时候的环境。</p>
<p><strong>先看下面这个函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> city = <span class="string">"西安"</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCity</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(city);</div><div class="line">  &#125;</div><div class="line">  getCity();</div><div class="line">&#125;</div><div class="line">foo();<span class="comment">//控制台输出'西安'</span></div></pre></td></tr></table></figure>
<p>函数 foo() 创建了一个局部变量 city，然后定义了名为 getCity() 的函数。 getCity() 是一个内部函数——定义于 foo() 之内且仅在该函数体内可用。getCity() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数中声明的 city 变量。</p>
<h4 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h4><p><strong>再看这样一个函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> city = <span class="string">"西安"</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCity</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(city);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> getCity;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo2 = foo1();</div><div class="line">foo2();<span class="comment">//控制台输出西安</span></div></pre></td></tr></table></figure></p>
<p> 运行这段代码的效果和之前的 foo() 示例完全一样：字符串 “西安” 将被显示在一个 控制台中。其中的不同也是有意思的地方在于 getCity()内部函数在执行前被从其外围函数foo1中返回了。</p>
<p>这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。一旦foo1()执行过后，我们会很合理的认为 city变量将不再可用。虽然代码运行的没问题，但实际并不是这样的。</p>
<p>这个谜题的答案是foo1变成一个闭包了。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，foo1是一个闭包，由getCity函数和闭包创建时存在的”西安”字符串形成。</p>
<p>下面是一个更有意思的示例 — makeAdder 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</div><div class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></div></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了 makeAdder(x) 函数：带有一个参数 x 并返回一个新的函数。返回的函数带有一个参数 y，并返回 x 和 y 的和。</p>
<p>从本质上讲，makeAdder 是一个函数工厂 — 创建将指定的值和它的参数求和的函数，在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p>
<p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p>
<p>实用的闭包<br>理论就是这些了 — 可是闭包确实有用吗？让我们看看闭包的实践意义。闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>
<p>因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。</p>
<p>在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：响应事件而执行的函数。</p>
<p>以下是一个实际的示例：假设我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如页眉）的字号：</p>
<p>body {<br>  font-family: Helvetica, Arial, sans-serif;<br>  font-size: 12px;<br>}</p>
<p>h1 {<br>  font-size: 1.5em;<br>}<br>h2 {<br>  font-size: 1.2em;<br>}<br>我们的交互式的文本尺寸按钮可以修改 body 元素的 font-size 属性，而由于我们使用相对的单位，页面中的其它元素也会相应地调整。</p>
<p>以下是 JavaScript：</p>
<p>function makeSizer(size) {<br>  return function() {<br>    document.body.style.fontSize = size + ‘px’;<br>  };<br>}</p>
<p>var size12 = makeSizer(12);<br>var size14 = makeSizer(14);<br>var size16 = makeSizer(16);<br>size12，size14 和 size16 为将 body 文本相应地调整为 12，14，16 像素的函数。我们可以将它们分别添加到按钮上（这里是链接）。如下所示：</p>
<p>document.getElementById(‘size-12’).onclick = size12;<br>document.getElementById(‘size-14’).onclick = size14;<br>document.getElementById(‘size-16’).onclick = size16;<br><a href="#" id="size-12">12</a><br><a href="#" id="size-14">14</a><br><a href="#" id="size-16">16</a></p>
<p>用闭包模拟私有方法<br>诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p>
<p>对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>
<p>下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：</p>
<p>var Counter = (function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>})();</p>
<p>console.log(Counter.value()); /<em> logs 0 </em>/<br>Counter.increment();<br>Counter.increment();<br>console.log(Counter.value()); /<em> logs 2 </em>/<br>Counter.decrement();<br>console.log(Counter.value()); /<em> logs 1 </em>/<br>这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。</p>
<p>该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。</p>
<p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。</p>
<p>您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。</p>
<p>var makeCounter = function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>};</p>
<p>var Counter1 = makeCounter();<br>var Counter2 = makeCounter();<br>console.log(Counter1.value()); /<em> logs 0 </em>/<br>Counter1.increment();<br>Counter1.increment();<br>console.log(Counter1.value()); /<em> logs 2 </em>/<br>Counter1.decrement();<br>console.log(Counter1.value()); /<em> logs 1 </em>/<br>console.log(Counter2.value()); /<em> logs 0 </em>/<br>请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。</p>
<p>这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。</p>
<p>在循环中创建闭包：一个常见错误<br>在 JavaScript 1.7 引入 let 关键字 之前，闭包的一个常见的问题发生于在循环中创建闭包。参考下面的示例：</p>
<p></p><p id="help">Helpful notes will appear here</p><p></p>
<p></p><p>E-mail: <input type="text" id="email" name="email"></p><p></p>
<p></p><p>Name: <input type="text" id="name" name="name"></p><p></p>
<p></p><p>Age: <input type="text" id="age" name="age"></p><br>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}<p></p>
<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>
<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = function() {<br>      showHelp(item.help);<br>    }<br>  }<br>}</p>
<p>setupHelp();</p>
<p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。</p>
<p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。</p>
<p>该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。</p>
<p>解决这个问题的一种方案是使onfocus指向一个新的闭包对象。</p>
<p>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}</p>
<p>function makeHelpCallback(help) {<br>  return function() {<br>    showHelp(help);<br>  };<br>}</p>
<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>
<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);<br>  }<br>}</p>
<p>setupHelp();</p>
<p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的环境。在这些环境中，help 指向 helpText 数组中对应的字符串。</p>
<p>性能考量<br>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</p>
<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。</p>
<p>考虑以下虽然不切实际但却说明问题的示例：</p>
<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>  this.getName = function() {<br>    return this.name;<br>  };</p>
<p>  this.getMessage = function() {<br>    return this.message;<br>  };<br>}<br>上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式：</p>
<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype = {<br>  getName: function() {<br>    return this.name;<br>  },<br>  getMessage: function() {<br>    return this.message;<br>  }<br>};<br>或者改成：</p>
<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype.getName = function() {<br>  return this.name;<br>};<br>MyObject.prototype.getMessage = function() {<br>  return this.message;<br>};<br>在前面的两个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><div data-url="http://Racaly.github.io/2016/08/26/闭包/" data-id="civ0r8t700005zd7t0fiipec4" class="article-share-link"><span>分享到</span></div><div class="tags"><a href="/tags/javascript/">javascript</a></div><div class="post-nav"><a href="/2016/09/04/gitignore/" class="pre">git忽略</a><a href="/2016/07/13/into-project-shell/" class="next">制作一个进入项目目录的小脚本</a></div><div data-thread-key="2016/08/26/闭包/" data-title="Javascript闭包" data-url="http://Racaly.github.io/2016/08/26/闭包/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="搜索"/><input type="hidden" name="sitesearch" value="http://Racaly.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/其他/" style="font-size: 15px;">其他</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/host/">Chrome浏览器host配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/04/gitignore/">git忽略</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/26/闭包/">Javascript闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/13/into-project-shell/">制作一个进入项目目录的小脚本</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">金城的妖精见过米.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'racaly'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>